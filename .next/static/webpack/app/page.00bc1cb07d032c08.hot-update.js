"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/image/render.ts":
/*!*****************************!*\
  !*** ./lib/image/render.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createImageBitmapWithFallback: () => (/* binding */ createImageBitmapWithFallback),\n/* harmony export */   renderSuccessCanvas: () => (/* binding */ renderSuccessCanvas),\n/* harmony export */   renderToCanvas: () => (/* binding */ renderToCanvas)\n/* harmony export */ });\n/**\n * 이미지 렌더링 유틸리티\n * createImageBitmap을 사용하여 canvas에 이미지를 그립니다.\n * AVIF 실패 시 WebP로 fallback 처리\n */ async function renderToCanvas(canvas, fullBytes, format) {\n    console.log(\"Canvas 렌더링 시작 - 데이터 크기: \".concat(fullBytes.length, \" bytes, 포맷: \").concat(format));\n    const primaryMime = format === \"aeia\" ? \"image/avif\" : \"image/webp\";\n    const fallbackMime = format === \"aeia\" ? \"image/webp\" : \"image/avif\";\n    // 지원하는 이미지 형식 확인 (WebP, AVIF만 지원)\n    const hasRiffHeader = fullBytes[0] === 0x52 && fullBytes[1] === 0x49 && fullBytes[2] === 0x46 && fullBytes[3] === 0x46;\n    const hasWebpHeader = hasRiffHeader && fullBytes[8] === 0x57 && fullBytes[9] === 0x45 && fullBytes[10] === 0x42 && fullBytes[11] === 0x50;\n    const hasAvifHeader = fullBytes.slice(4, 8).every((byte, i)=>byte === [\n            0x66,\n            0x74,\n            0x79,\n            0x70\n        ][i]); // ftyp\n    const hasJpegHeader = fullBytes[0] === 0xFF && fullBytes[1] === 0xD8 && fullBytes[2] === 0xFF;\n    console.log(\"이미지 형식 확인: RIFF=\".concat(hasRiffHeader, \", WebP=\").concat(hasWebpHeader, \", AVIF=\").concat(hasAvifHeader, \", JPEG=\").concat(hasJpegHeader));\n    // JPEG 등 지원하지 않는 형식 체크\n    if (hasJpegHeader) {\n        console.log('❌ JPEG 형식은 지원하지 않습니다. WebP/AVIF만 지원합니다.');\n        renderUnsupportedFormatCanvas(canvas, 'JPEG');\n        return;\n    }\n    if (!hasRiffHeader || !hasWebpHeader && !hasAvifHeader) {\n        // 지원하는 이미지 형식이 아니면 텍스트로 표시\n        console.log('⚠️ 지원하지 않는 이미지 형식. WebP/AVIF만 지원됩니다.');\n        renderTextToCanvas(canvas, fullBytes);\n        return;\n    }\n    // 복호화에서 이미 정확한 크기로 전달되므로 전체 데이터 사용\n    console.log(\"받은 이미지 데이터 크기: \".concat(fullBytes.length, \" bytes\"));\n    const webpData = fullBytes;\n    let bitmap = null;\n    try {\n        // 직접 Blob에서 ImageBitmap 생성 시도\n        const blob = new Blob([\n            webpData\n        ], {\n            type: 'image/webp'\n        });\n        console.log(\"image/webp 형식으로 디코딩 시도 (\".concat(webpData.length, \" bytes)\"));\n        console.log('WebP 데이터 샘플 (hex):', Array.from(webpData.slice(0, 32)).map((b)=>b.toString(16).padStart(2, '0')).join(' '));\n        bitmap = await createImageBitmap(blob);\n        console.log(\"✅ image/webp 디코딩 성공\");\n    } catch (primaryError) {\n        console.warn(\"image/webp 디코딩 실패, Image 객체로 재시도:\", primaryError);\n        try {\n            // Image 객체를 사용한 fallback 방식\n            const imageObj = new Image();\n            const canvas2d = document.createElement('canvas');\n            const ctx2d = canvas2d.getContext('2d');\n            if (!ctx2d) {\n                throw new Error('Canvas 2D context 생성 실패');\n            }\n            // Base64 변환로 시도\n            const base64 = btoa(String.fromCharCode(...webpData));\n            const dataUrl = \"data:image/webp;base64,\".concat(base64);\n            console.log('🔄 Image 객체 + Base64 방식으로 재시도...');\n            await new Promise((resolve, reject)=>{\n                imageObj.onload = ()=>{\n                    try {\n                        canvas2d.width = imageObj.naturalWidth;\n                        canvas2d.height = imageObj.naturalHeight;\n                        ctx2d.drawImage(imageObj, 0, 0);\n                        // 임시 Canvas에서 ImageBitmap 생성\n                        createImageBitmap(canvas2d).then((bmp)=>{\n                            bitmap = bmp;\n                            console.log('✅ Image 객체 방식 성공!');\n                            resolve();\n                        }).catch(reject);\n                    } catch (drawError) {\n                        reject(drawError);\n                    }\n                };\n                imageObj.onerror = reject;\n                imageObj.src = dataUrl;\n            });\n            if (!bitmap) {\n                throw new Error('Image 객체 방식 실패');\n            }\n        } catch (fallbackError) {\n            console.error('모든 이미지 디코딩 방식 실패, 텍스트 모드로 전환');\n            console.log('디코딩 실패 상세:', {\n                primaryError,\n                fallbackError\n            });\n            // 텍스트 모드에서 성공 표시 (복호화 성공이지만 이미지 디코딩 실패)\n            renderSuccessCanvas(canvas, fullBytes);\n            return;\n        }\n    }\n    try {\n        canvas.width = bitmap.width;\n        canvas.height = bitmap.height;\n        console.log(\"Canvas 크기 설정: \".concat(canvas.width, \"x\").concat(canvas.height));\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) {\n            throw new Error(\"Canvas 2D context를 가져올 수 없습니다.\");\n        }\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.drawImage(bitmap, 0, 0);\n        console.log(\"✅ Canvas 렌더링 완료 - 크기: \".concat(canvas.width, \"x\").concat(canvas.height));\n    } catch (renderError) {\n        console.error('Canvas 렌더링 중 오류:', renderError);\n        throw renderError;\n    } finally{\n        try {\n            bitmap.close();\n        } catch (closeError) {\n            console.warn('bitmap.close() 실패:', closeError);\n        }\n    }\n}\nfunction renderTextToCanvas(canvas, fullBytes) {\n    canvas.width = 500;\n    canvas.height = 400;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    // 배경\n    ctx.fillStyle = '#f8f9fa';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // 테두리\n    ctx.strokeStyle = '#dee2e6';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n    // 제목\n    ctx.fillStyle = '#28a745';\n    ctx.font = 'bold 18px system-ui, -apple-system, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('🎉 복호화 성공!', canvas.width / 2, 60);\n    // 식별 패턴 확인\n    const resultStr = new TextDecoder('utf-8', {\n        fatal: false\n    }).decode(fullBytes.slice(0, 2000));\n    ctx.fillStyle = '#6c757d';\n    ctx.font = '14px system-ui, -apple-system, sans-serif';\n    if (resultStr.includes('ENCRYPTED_DEMO_IMAGE_SUCCESS')) {\n        ctx.fillStyle = '#28a745';\n        ctx.fillText('✅ 식별 패턴 \"ENCRYPTED_DEMO_IMAGE_SUCCESS\" 발견', canvas.width / 2, 120);\n    }\n    const hasRiff = fullBytes[0] === 0x52 && fullBytes[1] === 0x49 && fullBytes[2] === 0x46 && fullBytes[3] === 0x46;\n    const hasWebp = hasRiff && fullBytes[8] === 0x57 && fullBytes[9] === 0x45 && fullBytes[10] === 0x42 && fullBytes[11] === 0x50;\n    if (hasRiff && hasWebp) {\n        ctx.fillStyle = '#17a2b8';\n        ctx.fillText('✅ 유효한 WebP 형식 헤더 확인됨', canvas.width / 2, 150);\n        const riffSize = (fullBytes[4] | fullBytes[5] << 8 | fullBytes[6] << 16 | fullBytes[7] << 24) + 8;\n        ctx.fillStyle = '#6c757d';\n        ctx.fillText(\"WebP 크기: \".concat(riffSize, \" bytes\"), canvas.width / 2, 175);\n    }\n    // 데이터 정보\n    ctx.fillStyle = '#6c757d';\n    ctx.font = '12px system-ui, -apple-system, sans-serif';\n    ctx.fillText(\"데이터 크기: \".concat(fullBytes.length.toLocaleString(), \" bytes\"), canvas.width / 2, 200);\n    ctx.fillText('복호화된 바이너리 데이터를 텍스트로 표시 중...', canvas.width / 2, 220);\n    // 샘플 데이터 표시\n    ctx.font = '10px monospace';\n    ctx.fillStyle = '#495057';\n    const sampleText = resultStr.slice(0, 100).replace(/[^\\x20-\\x7E]/g, '·');\n    const lines = [];\n    for(let i = 0; i < sampleText.length; i += 50){\n        lines.push(sampleText.slice(i, i + 50));\n    }\n    lines.forEach((line, index)=>{\n        ctx.fillText(line, canvas.width / 2, 260 + index * 15);\n    });\n    console.log('✅ 텍스트 모드 렌더링 완료');\n}\n/**\n * 복호화 성공 시 Canvas에 성공 메시지 렌더링\n */ function renderSuccessCanvas(canvas, fullBytes) {\n    canvas.width = 500;\n    canvas.height = 400;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    // 배경\n    ctx.fillStyle = '#f8f9fa';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // 테두리\n    ctx.strokeStyle = '#28a745';\n    ctx.lineWidth = 3;\n    ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n    // 제목\n    ctx.fillStyle = '#28a745';\n    ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('🎉 AES-GCM 복호화 성공!', canvas.width / 2, 80);\n    // 부제목\n    ctx.fillStyle = '#17a2b8';\n    ctx.font = 'bold 16px system-ui, -apple-system, sans-serif';\n    ctx.fillText('✅ 암호화된 이미지가 성공적으로 복호화되었습니다', canvas.width / 2, 120);\n    // 데이터 정보\n    ctx.fillStyle = '#6c757d';\n    ctx.font = '14px system-ui, -apple-system, sans-serif';\n    ctx.fillText(\"복호화된 데이터 크기: \".concat(fullBytes.length.toLocaleString(), \" bytes\"), canvas.width / 2, 160);\n    // 헤더 검증 결과\n    const hasRiff = fullBytes[0] === 0x52 && fullBytes[1] === 0x49 && fullBytes[2] === 0x46 && fullBytes[3] === 0x46;\n    const hasWebp = hasRiff && fullBytes[8] === 0x57 && fullBytes[9] === 0x45 && fullBytes[10] === 0x42 && fullBytes[11] === 0x50;\n    if (hasRiff && hasWebp) {\n        ctx.fillStyle = '#28a745';\n        ctx.fillText('✅ 유효한 WebP 이미지 형식 확인', canvas.width / 2, 190);\n    } else {\n        ctx.fillStyle = '#ffc107';\n        ctx.fillText('⚠️ 이미지 형식 확인 불가 (바이너리 데이터)', canvas.width / 2, 190);\n    }\n    // 기술 정보\n    ctx.fillStyle = '#495057';\n    ctx.font = '12px system-ui, -apple-system, sans-serif';\n    ctx.fillText('• AES-GCM-256 알고리즘 사용', canvas.width / 2, 230);\n    ctx.fillText('• Canvas API를 통한 브라우저 렌더링', canvas.width / 2, 250);\n    ctx.fillText('• Next.js Client Component 환경', canvas.width / 2, 270);\n    // Blob URL 생성 안내\n    ctx.fillStyle = '#6f42c1';\n    ctx.font = 'bold 14px system-ui, -apple-system, sans-serif';\n    ctx.fillText('💡 아래에서 Blob URL로 변환된 이미지도 확인하세요!', canvas.width / 2, 310);\n    console.log('✅ renderSuccessCanvas 렌더링 완료');\n}\n/**\n * 지원하지 않는 이미지 형식에 대한 오류 메시지 렌더링\n */ function renderUnsupportedFormatCanvas(canvas, format) {\n    canvas.width = 500;\n    canvas.height = 400;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    // 배경\n    ctx.fillStyle = '#fff5f5';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // 테두리\n    ctx.strokeStyle = '#e53e3e';\n    ctx.lineWidth = 3;\n    ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n    // 제목\n    ctx.fillStyle = '#e53e3e';\n    ctx.font = 'bold 24px system-ui, -apple-system, sans-serif';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('❌ 지원하지 않는 이미지 형식', canvas.width / 2, 80);\n    // 부제목\n    ctx.fillStyle = '#c53030';\n    ctx.font = 'bold 18px system-ui, -apple-system, sans-serif';\n    ctx.fillText(\"\".concat(format, \" 형식은 지원되지 않습니다\"), canvas.width / 2, 120);\n    // 지원 형식 안내\n    ctx.fillStyle = '#2d3748';\n    ctx.font = '16px system-ui, -apple-system, sans-serif';\n    ctx.fillText('지원하는 형식:', canvas.width / 2, 170);\n    ctx.fillStyle = '#38a169';\n    ctx.font = 'bold 18px system-ui, -apple-system, sans-serif';\n    ctx.fillText('✅ WebP (.webp)', canvas.width / 2, 200);\n    ctx.fillText('✅ AVIF (.avif)', canvas.width / 2, 230);\n    // 안내 메시지\n    ctx.fillStyle = '#4a5568';\n    ctx.font = '14px system-ui, -apple-system, sans-serif';\n    ctx.fillText('WebP 또는 AVIF 형식의 이미지를 사용해주세요.', canvas.width / 2, 280);\n    ctx.fillText('이 서비스는 차세대 이미지 포맷만 지원합니다.', canvas.width / 2, 300);\n    // 기술 정보\n    ctx.fillStyle = '#718096';\n    ctx.font = '12px system-ui, -apple-system, sans-serif';\n    ctx.fillText('• WebP: Google에서 개발한 고효율 이미지 포맷', canvas.width / 2, 340);\n    ctx.fillText('• AVIF: 차세대 이미지 표준 (더 높은 압축률)', canvas.width / 2, 360);\n    console.log(\"✅ \".concat(format, \" 형식 지원 안내 렌더링 완료\"));\n}\n/**\n * 이미지 비트맵 생성 with fallback (예비용 함수)\n */ async function createImageBitmapWithFallback(bytes, format) {\n    const primaryMime = format === \"aeia\" ? \"image/avif\" : \"image/webp\";\n    const fallbackMime = format === \"aeia\" ? \"image/webp\" : \"image/avif\";\n    try {\n        const blob = new Blob([\n            bytes.slice()\n        ], {\n            type: primaryMime\n        });\n        return await createImageBitmap(blob);\n    } catch (primaryError) {\n        console.warn(\"\".concat(primaryMime, \" 디코딩 실패, \").concat(fallbackMime, \"로 재시도:\"), primaryError);\n        const fallbackBlob = new Blob([\n            bytes.slice()\n        ], {\n            type: fallbackMime\n        });\n        return await createImageBitmap(fallbackBlob);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VyxNQUFNaEI7UUFBWTtRQUMzRCxPQUFPLE1BQU13QixrQkFBa0JWO0lBQ2pDLEVBQUUsT0FBT1csY0FBYztRQUNyQjVCLFFBQVE2QixJQUFJLENBQUMsR0FBMEJ6QixPQUF2QkQsYUFBWSxhQUF3QixPQUFiQyxjQUFhLFdBQVN3QjtRQUU3RCxNQUFNaUUsZUFBZSxJQUFJM0UsS0FBSztZQUFDMEUsTUFBTXBGLEtBQUs7U0FBRyxFQUFFO1lBQUVXLE1BQU1mO1FBQWE7UUFDcEUsT0FBTyxNQUFNdUIsa0JBQWtCa0U7SUFDakM7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2Rhc29sbGVlL0Rvd25sb2Fkcy9HaXRBbGFkaW4vRkVfSW1hZ2VTZXJ2aWNlUmVxdWlyZW1lbnRzL2xpYi9pbWFnZS9yZW5kZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDsnbTrr7jsp4Ag66CM642U66eBIOycoO2LuOumrO2LsFxuICogY3JlYXRlSW1hZ2VCaXRtYXDsnYQg7IKs7Jqp7ZWY7JesIGNhbnZhc+yXkCDsnbTrr7jsp4Drpbwg6re466a964uI64ukLlxuICogQVZJRiDsi6TtjKgg7IucIFdlYlDroZwgZmFsbGJhY2sg7LKY66asXG4gKi9cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmRlclRvQ2FudmFzKFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICBmdWxsQnl0ZXM6IFVpbnQ4QXJyYXksXG4gIGZvcm1hdDogXCJhZWlhXCIgfCBcImFlaXdcIlxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnNvbGUubG9nKGBDYW52YXMg66CM642U66eBIOyLnOyekSAtIOuNsOydtO2EsCDtgazquLA6ICR7ZnVsbEJ5dGVzLmxlbmd0aH0gYnl0ZXMsIO2PrOuntzogJHtmb3JtYXR9YCk7XG4gIFxuICBjb25zdCBwcmltYXJ5TWltZSA9IGZvcm1hdCA9PT0gXCJhZWlhXCIgPyBcImltYWdlL2F2aWZcIiA6IFwiaW1hZ2Uvd2VicFwiO1xuICBjb25zdCBmYWxsYmFja01pbWUgPSBmb3JtYXQgPT09IFwiYWVpYVwiID8gXCJpbWFnZS93ZWJwXCIgOiBcImltYWdlL2F2aWZcIjtcblxuICAvLyDsp4Dsm5DtlZjripQg7J2066+47KeAIO2YleyLnSDtmZXsnbggKFdlYlAsIEFWSUbrp4wg7KeA7JuQKVxuICBjb25zdCBoYXNSaWZmSGVhZGVyID0gZnVsbEJ5dGVzWzBdID09PSAweDUyICYmIGZ1bGxCeXRlc1sxXSA9PT0gMHg0OSAmJiBmdWxsQnl0ZXNbMl0gPT09IDB4NDYgJiYgZnVsbEJ5dGVzWzNdID09PSAweDQ2O1xuICBjb25zdCBoYXNXZWJwSGVhZGVyID0gaGFzUmlmZkhlYWRlciAmJiBmdWxsQnl0ZXNbOF0gPT09IDB4NTcgJiYgZnVsbEJ5dGVzWzldID09PSAweDQ1ICYmIGZ1bGxCeXRlc1sxMF0gPT09IDB4NDIgJiYgZnVsbEJ5dGVzWzExXSA9PT0gMHg1MDtcbiAgY29uc3QgaGFzQXZpZkhlYWRlciA9IGZ1bGxCeXRlcy5zbGljZSg0LCA4KS5ldmVyeSgoYnl0ZSwgaSkgPT4gYnl0ZSA9PT0gWzB4NjYsIDB4NzQsIDB4NzksIDB4NzBdW2ldKTsgLy8gZnR5cFxuICBjb25zdCBoYXNKcGVnSGVhZGVyID0gZnVsbEJ5dGVzWzBdID09PSAweEZGICYmIGZ1bGxCeXRlc1sxXSA9PT0gMHhEOCAmJiBmdWxsQnl0ZXNbMl0gPT09IDB4RkY7XG4gIFxuICBjb25zb2xlLmxvZyhg7J2066+47KeAIO2YleyLnSDtmZXsnbg6IFJJRkY9JHtoYXNSaWZmSGVhZGVyfSwgV2ViUD0ke2hhc1dlYnBIZWFkZXJ9LCBBVklGPSR7aGFzQXZpZkhlYWRlcn0sIEpQRUc9JHtoYXNKcGVnSGVhZGVyfWApO1xuICBcbiAgLy8gSlBFRyDrk7Eg7KeA7JuQ7ZWY7KeAIOyViuuKlCDtmJXsi50g7LK07YGsXG4gIGlmIChoYXNKcGVnSGVhZGVyKSB7XG4gICAgY29uc29sZS5sb2coJ+KdjCBKUEVHIO2YleyLneydgCDsp4Dsm5DtlZjsp4Ag7JWK7Iq164uI64ukLiBXZWJQL0FWSUbrp4wg7KeA7JuQ7ZWp64uI64ukLicpO1xuICAgIHJlbmRlclVuc3VwcG9ydGVkRm9ybWF0Q2FudmFzKGNhbnZhcywgJ0pQRUcnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIGlmICghaGFzUmlmZkhlYWRlciB8fCAoIWhhc1dlYnBIZWFkZXIgJiYgIWhhc0F2aWZIZWFkZXIpKSB7XG4gICAgLy8g7KeA7JuQ7ZWY64qUIOydtOuvuOyngCDtmJXsi53snbQg7JWE64uI66m0IO2FjeyKpO2KuOuhnCDtkZzsi5xcbiAgICBjb25zb2xlLmxvZygn4pqg77iPIOyngOybkO2VmOyngCDslYrripQg7J2066+47KeAIO2YleyLnS4gV2ViUC9BVklG66eMIOyngOybkOuQqeuLiOuLpC4nKTtcbiAgICByZW5kZXJUZXh0VG9DYW52YXMoY2FudmFzLCBmdWxsQnl0ZXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgLy8g67O17Zi47ZmU7JeQ7IScIOydtOuvuCDsoJXtmZXtlZwg7YGs6riw66GcIOyghOuLrOuQmOuvgOuhnCDsoITssrQg642w7J207YSwIOyCrOyaqVxuICBjb25zb2xlLmxvZyhg67Cb7J2AIOydtOuvuOyngCDrjbDsnbTthLAg7YGs6riwOiAke2Z1bGxCeXRlcy5sZW5ndGh9IGJ5dGVzYCk7XG4gIGNvbnN0IHdlYnBEYXRhID0gZnVsbEJ5dGVzO1xuXG4gIGxldCBiaXRtYXA6IEltYWdlQml0bWFwIHwgbnVsbCA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICAvLyDsp4HsoJEgQmxvYuyXkOyEnCBJbWFnZUJpdG1hcCDsg53shLEg7Iuc64+EXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFt3ZWJwRGF0YV0sIHsgdHlwZTogJ2ltYWdlL3dlYnAnIH0pO1xuICAgIGNvbnNvbGUubG9nKGBpbWFnZS93ZWJwIO2YleyLneycvOuhnCDrlJTsvZTrlKkg7Iuc64+EICgke3dlYnBEYXRhLmxlbmd0aH0gYnl0ZXMpYCk7XG4gICAgY29uc29sZS5sb2coJ1dlYlAg642w7J207YSwIOyDmO2UjCAoaGV4KTonLCBBcnJheS5mcm9tKHdlYnBEYXRhLnNsaWNlKDAsIDMyKSkubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignICcpKTtcbiAgICBcbiAgICBiaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICBjb25zb2xlLmxvZyhg4pyFIGltYWdlL3dlYnAg65SU7L2U65SpIOyEseqztWApO1xuICB9IGNhdGNoIChwcmltYXJ5RXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oYGltYWdlL3dlYnAg65SU7L2U65SpIOyLpO2MqCwgSW1hZ2Ug6rCd7LK066GcIOyerOyLnOuPhDpgLCBwcmltYXJ5RXJyb3IpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJbWFnZSDqsJ3ssrTrpbwg7IKs7Jqp7ZWcIGZhbGxiYWNrIOuwqeyLnVxuICAgICAgY29uc3QgaW1hZ2VPYmogPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGNvbnN0IGNhbnZhczJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjb25zdCBjdHgyZCA9IGNhbnZhczJkLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICAgIGlmICghY3R4MmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgMkQgY29udGV4dCDsg53shLEg7Iuk7YyoJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEJhc2U2NCDrs4DtmZjroZwg7Iuc64+EXG4gICAgICBjb25zdCBiYXNlNjQgPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ud2VicERhdGEpKTtcbiAgICAgIGNvbnN0IGRhdGFVcmwgPSBgZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCwke2Jhc2U2NH1gO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBJbWFnZSDqsJ3ssrQgKyBCYXNlNjQg67Cp7Iud7Jy866GcIOyerOyLnOuPhC4uLicpO1xuICAgICAgXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGltYWdlT2JqLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FudmFzMmQud2lkdGggPSBpbWFnZU9iai5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICBjYW52YXMyZC5oZWlnaHQgPSBpbWFnZU9iai5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgY3R4MmQuZHJhd0ltYWdlKGltYWdlT2JqLCAwLCAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8g7J6E7IucIENhbnZhc+yXkOyEnCBJbWFnZUJpdG1hcCDsg53shLFcbiAgICAgICAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGNhbnZhczJkKS50aGVuKGJtcCA9PiB7XG4gICAgICAgICAgICAgIGJpdG1hcCA9IGJtcDtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBJbWFnZSDqsJ3ssrQg67Cp7IudIOyEseqztSEnKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICB9IGNhdGNoIChkcmF3RXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChkcmF3RXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2VPYmoub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgaW1hZ2VPYmouc3JjID0gZGF0YVVybDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIWJpdG1hcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIOqwneyytCDrsKnsi50g7Iuk7YyoJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign66qo65OgIOydtOuvuOyngCDrlJTsvZTrlKkg67Cp7IudIOyLpO2MqCwg7YWN7Iqk7Yq4IOuqqOuTnOuhnCDsoITtmZgnKTtcbiAgICAgIGNvbnNvbGUubG9nKCfrlJTsvZTrlKkg7Iuk7YyoIOyDgeyEuDonLCB7IHByaW1hcnlFcnJvciwgZmFsbGJhY2tFcnJvciB9KTtcbiAgICAgIFxuICAgICAgLy8g7YWN7Iqk7Yq4IOuqqOuTnOyXkOyEnCDshLHqs7Ug7ZGc7IucICjrs7XtmLjtmZQg7ISx6rO17J207KeA66eMIOydtOuvuOyngCDrlJTsvZTrlKkg7Iuk7YyoKVxuICAgICAgcmVuZGVyU3VjY2Vzc0NhbnZhcyhjYW52YXMsIGZ1bGxCeXRlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjYW52YXMud2lkdGggPSBiaXRtYXAud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGJpdG1hcC5oZWlnaHQ7XG4gICAgY29uc29sZS5sb2coYENhbnZhcyDtgazquLAg7ISk7KCVOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIDJEIGNvbnRleHTrpbwg6rCA7KC47JisIOyImCDsl4bsirXri4jri6QuXCIpO1xuICAgIH1cblxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYOKchSBDYW52YXMg66CM642U66eBIOyZhOujjCAtIO2BrOq4sDogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gKTtcbiAgfSBjYXRjaCAocmVuZGVyRXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdDYW52YXMg66CM642U66eBIOykkSDsmKTrpZg6JywgcmVuZGVyRXJyb3IpO1xuICAgIHRocm93IHJlbmRlckVycm9yO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBiaXRtYXAuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChjbG9zZUVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2JpdG1hcC5jbG9zZSgpIOyLpO2MqDonLCBjbG9zZUVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyVGV4dFRvQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGZ1bGxCeXRlczogVWludDhBcnJheSkge1xuICBjYW52YXMud2lkdGggPSA1MDA7XG4gIGNhbnZhcy5oZWlnaHQgPSA0MDA7XG4gIFxuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBpZiAoIWN0eCkgcmV0dXJuO1xuICBcbiAgLy8g67Cw6rK9XG4gIGN0eC5maWxsU3R5bGUgPSAnI2Y4ZjlmYSc7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBcbiAgLy8g7YWM65GQ66asXG4gIGN0eC5zdHJva2VTdHlsZSA9ICcjZGVlMmU2JztcbiAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gIGN0eC5zdHJva2VSZWN0KDEsIDEsIGNhbnZhcy53aWR0aCAtIDIsIGNhbnZhcy5oZWlnaHQgLSAyKTtcbiAgXG4gIC8vIOygnOuqqVxuICBjdHguZmlsbFN0eWxlID0gJyMyOGE3NDUnO1xuICBjdHguZm9udCA9ICdib2xkIDE4cHggc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBzYW5zLXNlcmlmJztcbiAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gIGN0eC5maWxsVGV4dCgn8J+OiSDrs7XtmLjtmZQg7ISx6rO1IScsIGNhbnZhcy53aWR0aCAvIDIsIDYwKTtcbiAgXG4gIC8vIOyLneuzhCDtjKjthLQg7ZmV7J24XG4gIGNvbnN0IHJlc3VsdFN0ciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiBmYWxzZSB9KS5kZWNvZGUoZnVsbEJ5dGVzLnNsaWNlKDAsIDIwMDApKTtcbiAgXG4gIGN0eC5maWxsU3R5bGUgPSAnIzZjNzU3ZCc7XG4gIGN0eC5mb250ID0gJzE0cHggc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBzYW5zLXNlcmlmJztcbiAgXG4gIGlmIChyZXN1bHRTdHIuaW5jbHVkZXMoJ0VOQ1JZUFRFRF9ERU1PX0lNQUdFX1NVQ0NFU1MnKSkge1xuICAgIGN0eC5maWxsU3R5bGUgPSAnIzI4YTc0NSc7XG4gICAgY3R4LmZpbGxUZXh0KCfinIUg7Iud67OEIO2MqO2EtCBcIkVOQ1JZUFRFRF9ERU1PX0lNQUdFX1NVQ0NFU1NcIiDrsJzqsqwnLCBjYW52YXMud2lkdGggLyAyLCAxMjApO1xuICB9XG4gIFxuICBjb25zdCBoYXNSaWZmID0gZnVsbEJ5dGVzWzBdID09PSAweDUyICYmIGZ1bGxCeXRlc1sxXSA9PT0gMHg0OSAmJiBmdWxsQnl0ZXNbMl0gPT09IDB4NDYgJiYgZnVsbEJ5dGVzWzNdID09PSAweDQ2O1xuICBjb25zdCBoYXNXZWJwID0gaGFzUmlmZiAmJiBmdWxsQnl0ZXNbOF0gPT09IDB4NTcgJiYgZnVsbEJ5dGVzWzldID09PSAweDQ1ICYmIGZ1bGxCeXRlc1sxMF0gPT09IDB4NDIgJiYgZnVsbEJ5dGVzWzExXSA9PT0gMHg1MDtcbiAgXG4gIGlmIChoYXNSaWZmICYmIGhhc1dlYnApIHtcbiAgICBjdHguZmlsbFN0eWxlID0gJyMxN2EyYjgnO1xuICAgIGN0eC5maWxsVGV4dCgn4pyFIOycoO2aqO2VnCBXZWJQIO2YleyLnSDtl6TrjZQg7ZmV7J2465CoJywgY2FudmFzLndpZHRoIC8gMiwgMTUwKTtcbiAgICBcbiAgICBjb25zdCByaWZmU2l6ZSA9IChmdWxsQnl0ZXNbNF0gfCAoZnVsbEJ5dGVzWzVdIDw8IDgpIHwgKGZ1bGxCeXRlc1s2XSA8PCAxNikgfCAoZnVsbEJ5dGVzWzddIDw8IDI0KSkgKyA4O1xuICAgIGN0eC5maWxsU3R5bGUgPSAnIzZjNzU3ZCc7XG4gICAgY3R4LmZpbGxUZXh0KGBXZWJQIO2BrOq4sDogJHtyaWZmU2l6ZX0gYnl0ZXNgLCBjYW52YXMud2lkdGggLyAyLCAxNzUpO1xuICB9XG4gIFxuICAvLyDrjbDsnbTthLAg7KCV67O0XG4gIGN0eC5maWxsU3R5bGUgPSAnIzZjNzU3ZCc7XG4gIGN0eC5mb250ID0gJzEycHggc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBzYW5zLXNlcmlmJztcbiAgY3R4LmZpbGxUZXh0KGDrjbDsnbTthLAg7YGs6riwOiAke2Z1bGxCeXRlcy5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gYnl0ZXNgLCBjYW52YXMud2lkdGggLyAyLCAyMDApO1xuICBjdHguZmlsbFRleHQoJ+uzte2YuO2ZlOuQnCDrsJTsnbTrhIjrpqwg642w7J207YSw66W8IO2FjeyKpO2KuOuhnCDtkZzsi5wg7KSRLi4uJywgY2FudmFzLndpZHRoIC8gMiwgMjIwKTtcbiAgXG4gIC8vIOyDmO2UjCDrjbDsnbTthLAg7ZGc7IucXG4gIGN0eC5mb250ID0gJzEwcHggbW9ub3NwYWNlJztcbiAgY3R4LmZpbGxTdHlsZSA9ICcjNDk1MDU3JztcbiAgY29uc3Qgc2FtcGxlVGV4dCA9IHJlc3VsdFN0ci5zbGljZSgwLCAxMDApLnJlcGxhY2UoL1teXFx4MjAtXFx4N0VdL2csICfCtycpO1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZVRleHQubGVuZ3RoOyBpICs9IDUwKSB7XG4gICAgbGluZXMucHVzaChzYW1wbGVUZXh0LnNsaWNlKGksIGkgKyA1MCkpO1xuICB9XG4gIFxuICBsaW5lcy5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xuICAgIGN0eC5maWxsVGV4dChsaW5lLCBjYW52YXMud2lkdGggLyAyLCAyNjAgKyBpbmRleCAqIDE1KTtcbiAgfSk7XG4gIFxuICBjb25zb2xlLmxvZygn4pyFIO2FjeyKpO2KuCDrqqjrk5wg66CM642U66eBIOyZhOujjCcpO1xufVxuXG4vKipcbiAqIOuzte2YuO2ZlCDshLHqs7Ug7IucIENhbnZhc+yXkCDshLHqs7Ug66mU7Iuc7KeAIOugjOuNlOungVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU3VjY2Vzc0NhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBmdWxsQnl0ZXM6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgY2FudmFzLndpZHRoID0gNTAwO1xuICBjYW52YXMuaGVpZ2h0ID0gNDAwO1xuICBcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaWYgKCFjdHgpIHJldHVybjtcbiAgXG4gIC8vIOuwsOqyvVxuICBjdHguZmlsbFN0eWxlID0gJyNmOGY5ZmEnO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgXG4gIC8vIO2FjOuRkOumrFxuICBjdHguc3Ryb2tlU3R5bGUgPSAnIzI4YTc0NSc7XG4gIGN0eC5saW5lV2lkdGggPSAzO1xuICBjdHguc3Ryb2tlUmVjdCgxLCAxLCBjYW52YXMud2lkdGggLSAyLCBjYW52YXMuaGVpZ2h0IC0gMik7XG4gIFxuICAvLyDsoJzrqqlcbiAgY3R4LmZpbGxTdHlsZSA9ICcjMjhhNzQ1JztcbiAgY3R4LmZvbnQgPSAnYm9sZCAyNHB4IHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgc2Fucy1zZXJpZic7XG4gIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICBjdHguZmlsbFRleHQoJ/CfjokgQUVTLUdDTSDrs7XtmLjtmZQg7ISx6rO1IScsIGNhbnZhcy53aWR0aCAvIDIsIDgwKTtcbiAgXG4gIC8vIOu2gOygnOuqqVxuICBjdHguZmlsbFN0eWxlID0gJyMxN2EyYjgnO1xuICBjdHguZm9udCA9ICdib2xkIDE2cHggc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBzYW5zLXNlcmlmJztcbiAgY3R4LmZpbGxUZXh0KCfinIUg7JWU7Zi47ZmU65CcIOydtOuvuOyngOqwgCDshLHqs7XsoIHsnLzroZwg67O17Zi47ZmU65CY7JeI7Iq164uI64ukJywgY2FudmFzLndpZHRoIC8gMiwgMTIwKTtcbiAgXG4gIC8vIOuNsOydtO2EsCDsoJXrs7RcbiAgY3R4LmZpbGxTdHlsZSA9ICcjNmM3NTdkJztcbiAgY3R4LmZvbnQgPSAnMTRweCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIHNhbnMtc2VyaWYnO1xuICBjdHguZmlsbFRleHQoYOuzte2YuO2ZlOuQnCDrjbDsnbTthLAg7YGs6riwOiAke2Z1bGxCeXRlcy5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gYnl0ZXNgLCBjYW52YXMud2lkdGggLyAyLCAxNjApO1xuICBcbiAgLy8g7Zek642UIOqygOymnSDqsrDqs7xcbiAgY29uc3QgaGFzUmlmZiA9IGZ1bGxCeXRlc1swXSA9PT0gMHg1MiAmJiBmdWxsQnl0ZXNbMV0gPT09IDB4NDkgJiYgZnVsbEJ5dGVzWzJdID09PSAweDQ2ICYmIGZ1bGxCeXRlc1szXSA9PT0gMHg0NjtcbiAgY29uc3QgaGFzV2VicCA9IGhhc1JpZmYgJiYgZnVsbEJ5dGVzWzhdID09PSAweDU3ICYmIGZ1bGxCeXRlc1s5XSA9PT0gMHg0NSAmJiBmdWxsQnl0ZXNbMTBdID09PSAweDQyICYmIGZ1bGxCeXRlc1sxMV0gPT09IDB4NTA7XG4gIFxuICBpZiAoaGFzUmlmZiAmJiBoYXNXZWJwKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjMjhhNzQ1JztcbiAgICBjdHguZmlsbFRleHQoJ+KchSDsnKDtmqjtlZwgV2ViUCDsnbTrr7jsp4Ag7ZiV7IudIO2ZleyduCcsIGNhbnZhcy53aWR0aCAvIDIsIDE5MCk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZjMTA3JztcbiAgICBjdHguZmlsbFRleHQoJ+KaoO+4jyDsnbTrr7jsp4Ag7ZiV7IudIO2ZleyduCDrtojqsIAgKOuwlOydtOuEiOumrCDrjbDsnbTthLApJywgY2FudmFzLndpZHRoIC8gMiwgMTkwKTtcbiAgfVxuICBcbiAgLy8g6riw7IigIOygleuztFxuICBjdHguZmlsbFN0eWxlID0gJyM0OTUwNTcnO1xuICBjdHguZm9udCA9ICcxMnB4IHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgc2Fucy1zZXJpZic7XG4gIGN0eC5maWxsVGV4dCgn4oCiIEFFUy1HQ00tMjU2IOyVjOqzoOumrOymmCDsgqzsmqknLCBjYW52YXMud2lkdGggLyAyLCAyMzApO1xuICBjdHguZmlsbFRleHQoJ+KAoiBDYW52YXMgQVBJ66W8IO2Gte2VnCDruIzrnbzsmrDsoIAg66CM642U66eBJywgY2FudmFzLndpZHRoIC8gMiwgMjUwKTtcbiAgY3R4LmZpbGxUZXh0KCfigKIgTmV4dC5qcyBDbGllbnQgQ29tcG9uZW50IO2ZmOqyvScsIGNhbnZhcy53aWR0aCAvIDIsIDI3MCk7XG4gIFxuICAvLyBCbG9iIFVSTCDsg53shLEg7JWI64K0XG4gIGN0eC5maWxsU3R5bGUgPSAnIzZmNDJjMSc7XG4gIGN0eC5mb250ID0gJ2JvbGQgMTRweCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIHNhbnMtc2VyaWYnO1xuICBjdHguZmlsbFRleHQoJ/CfkqEg7JWE656Y7JeQ7IScIEJsb2IgVVJM66GcIOuzgO2ZmOuQnCDsnbTrr7jsp4Drj4Qg7ZmV7J247ZWY7IS47JqUIScsIGNhbnZhcy53aWR0aCAvIDIsIDMxMCk7XG4gIFxuICBjb25zb2xlLmxvZygn4pyFIHJlbmRlclN1Y2Nlc3NDYW52YXMg66CM642U66eBIOyZhOujjCcpO1xufVxuXG4vKipcbiAqIOyngOybkO2VmOyngCDslYrripQg7J2066+47KeAIO2YleyLneyXkCDrjIDtlZwg7Jik66WYIOuplOyLnOyngCDroIzrjZTrp4FcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVW5zdXBwb3J0ZWRGb3JtYXRDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgZm9ybWF0OiBzdHJpbmcpOiB2b2lkIHtcbiAgY2FudmFzLndpZHRoID0gNTAwO1xuICBjYW52YXMuaGVpZ2h0ID0gNDAwO1xuICBcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaWYgKCFjdHgpIHJldHVybjtcbiAgXG4gIC8vIOuwsOqyvVxuICBjdHguZmlsbFN0eWxlID0gJyNmZmY1ZjUnO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgXG4gIC8vIO2FjOuRkOumrFxuICBjdHguc3Ryb2tlU3R5bGUgPSAnI2U1M2UzZSc7XG4gIGN0eC5saW5lV2lkdGggPSAzO1xuICBjdHguc3Ryb2tlUmVjdCgxLCAxLCBjYW52YXMud2lkdGggLSAyLCBjYW52YXMuaGVpZ2h0IC0gMik7XG4gIFxuICAvLyDsoJzrqqlcbiAgY3R4LmZpbGxTdHlsZSA9ICcjZTUzZTNlJztcbiAgY3R4LmZvbnQgPSAnYm9sZCAyNHB4IHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgc2Fucy1zZXJpZic7XG4gIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICBjdHguZmlsbFRleHQoJ+KdjCDsp4Dsm5DtlZjsp4Ag7JWK64qUIOydtOuvuOyngCDtmJXsi50nLCBjYW52YXMud2lkdGggLyAyLCA4MCk7XG4gIFxuICAvLyDrtoDsoJzrqqlcbiAgY3R4LmZpbGxTdHlsZSA9ICcjYzUzMDMwJztcbiAgY3R4LmZvbnQgPSAnYm9sZCAxOHB4IHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgc2Fucy1zZXJpZic7XG4gIGN0eC5maWxsVGV4dChgJHtmb3JtYXR9IO2YleyLneydgCDsp4Dsm5DrkJjsp4Ag7JWK7Iq164uI64ukYCwgY2FudmFzLndpZHRoIC8gMiwgMTIwKTtcbiAgXG4gIC8vIOyngOybkCDtmJXsi50g7JWI64K0XG4gIGN0eC5maWxsU3R5bGUgPSAnIzJkMzc0OCc7XG4gIGN0eC5mb250ID0gJzE2cHggc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBzYW5zLXNlcmlmJztcbiAgY3R4LmZpbGxUZXh0KCfsp4Dsm5DtlZjripQg7ZiV7IudOicsIGNhbnZhcy53aWR0aCAvIDIsIDE3MCk7XG4gIFxuICBjdHguZmlsbFN0eWxlID0gJyMzOGExNjknO1xuICBjdHguZm9udCA9ICdib2xkIDE4cHggc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBzYW5zLXNlcmlmJztcbiAgY3R4LmZpbGxUZXh0KCfinIUgV2ViUCAoLndlYnApJywgY2FudmFzLndpZHRoIC8gMiwgMjAwKTtcbiAgY3R4LmZpbGxUZXh0KCfinIUgQVZJRiAoLmF2aWYpJywgY2FudmFzLndpZHRoIC8gMiwgMjMwKTtcbiAgXG4gIC8vIOyViOuCtCDrqZTsi5zsp4BcbiAgY3R4LmZpbGxTdHlsZSA9ICcjNGE1NTY4JztcbiAgY3R4LmZvbnQgPSAnMTRweCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIHNhbnMtc2VyaWYnO1xuICBjdHguZmlsbFRleHQoJ1dlYlAg65iQ64qUIEFWSUYg7ZiV7Iud7J2YIOydtOuvuOyngOulvCDsgqzsmqntlbTso7zshLjsmpQuJywgY2FudmFzLndpZHRoIC8gMiwgMjgwKTtcbiAgY3R4LmZpbGxUZXh0KCfsnbQg7ISc67mE7Iqk64qUIOywqOyEuOuMgCDsnbTrr7jsp4Ag7Y+s66e366eMIOyngOybkO2VqeuLiOuLpC4nLCBjYW52YXMud2lkdGggLyAyLCAzMDApO1xuICBcbiAgLy8g6riw7IigIOygleuztFxuICBjdHguZmlsbFN0eWxlID0gJyM3MTgwOTYnO1xuICBjdHguZm9udCA9ICcxMnB4IHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgc2Fucy1zZXJpZic7XG4gIGN0eC5maWxsVGV4dCgn4oCiIFdlYlA6IEdvb2dsZeyXkOyEnCDqsJzrsJztlZwg6rOg7Zqo7JyoIOydtOuvuOyngCDtj6zrp7cnLCBjYW52YXMud2lkdGggLyAyLCAzNDApO1xuICBjdHguZmlsbFRleHQoJ+KAoiBBVklGOiDssKjshLjrjIAg7J2066+47KeAIO2RnOykgCAo642UIOuGkuydgCDslZXstpXrpaApJywgY2FudmFzLndpZHRoIC8gMiwgMzYwKTtcbiAgXG4gIGNvbnNvbGUubG9nKGDinIUgJHtmb3JtYXR9IO2YleyLnSDsp4Dsm5Ag7JWI64K0IOugjOuNlOungSDsmYTro4xgKTtcbn1cblxuLyoqXG4gKiDsnbTrr7jsp4Ag67mE7Yq466e1IOyDneyEsSB3aXRoIGZhbGxiYWNrICjsmIjruYTsmqkg7ZWo7IiYKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlSW1hZ2VCaXRtYXBXaXRoRmFsbGJhY2soXG4gIGJ5dGVzOiBVaW50OEFycmF5LFxuICBmb3JtYXQ6IFwiYWVpYVwiIHwgXCJhZWl3XCJcbik6IFByb21pc2U8SW1hZ2VCaXRtYXA+IHtcbiAgY29uc3QgcHJpbWFyeU1pbWUgPSBmb3JtYXQgPT09IFwiYWVpYVwiID8gXCJpbWFnZS9hdmlmXCIgOiBcImltYWdlL3dlYnBcIjtcbiAgY29uc3QgZmFsbGJhY2tNaW1lID0gZm9ybWF0ID09PSBcImFlaWFcIiA/IFwiaW1hZ2Uvd2VicFwiIDogXCJpbWFnZS9hdmlmXCI7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J5dGVzLnNsaWNlKCldLCB7IHR5cGU6IHByaW1hcnlNaW1lIH0pO1xuICAgIHJldHVybiBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgfSBjYXRjaCAocHJpbWFyeUVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKGAke3ByaW1hcnlNaW1lfSDrlJTsvZTrlKkg7Iuk7YyoLCAke2ZhbGxiYWNrTWltZX3roZwg7J6s7Iuc64+EOmAsIHByaW1hcnlFcnJvcik7XG4gICAgXG4gICAgY29uc3QgZmFsbGJhY2tCbG9iID0gbmV3IEJsb2IoW2J5dGVzLnNsaWNlKCldLCB7IHR5cGU6IGZhbGxiYWNrTWltZSB9KTtcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoZmFsbGJhY2tCbG9iKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJyZW5kZXJUb0NhbnZhcyIsImNhbnZhcyIsImZ1bGxCeXRlcyIsImZvcm1hdCIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJwcmltYXJ5TWltZSIsImZhbGxiYWNrTWltZSIsImhhc1JpZmZIZWFkZXIiLCJoYXNXZWJwSGVhZGVyIiwiaGFzQXZpZkhlYWRlciIsInNsaWNlIiwiZXZlcnkiLCJieXRlIiwiaSIsImhhc0pwZWdIZWFkZXIiLCJyZW5kZXJVbnN1cHBvcnRlZEZvcm1hdENhbnZhcyIsInJlbmRlclRleHRUb0NhbnZhcyIsIndlYnBEYXRhIiwiYml0bWFwIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwiYiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJwcmltYXJ5RXJyb3IiLCJ3YXJuIiwiaW1hZ2VPYmoiLCJJbWFnZSIsImNhbnZhczJkIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4MmQiLCJnZXRDb250ZXh0IiwiRXJyb3IiLCJiYXNlNjQiLCJidG9hIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZGF0YVVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkIiwid2lkdGgiLCJuYXR1cmFsV2lkdGgiLCJoZWlnaHQiLCJuYXR1cmFsSGVpZ2h0IiwiZHJhd0ltYWdlIiwidGhlbiIsImJtcCIsImNhdGNoIiwiZHJhd0Vycm9yIiwib25lcnJvciIsInNyYyIsImZhbGxiYWNrRXJyb3IiLCJlcnJvciIsInJlbmRlclN1Y2Nlc3NDYW52YXMiLCJjdHgiLCJjbGVhclJlY3QiLCJyZW5kZXJFcnJvciIsImNsb3NlIiwiY2xvc2VFcnJvciIsImZpbGxTdHlsZSIsImZpbGxSZWN0Iiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2VSZWN0IiwiZm9udCIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwicmVzdWx0U3RyIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZSIsImluY2x1ZGVzIiwiaGFzUmlmZiIsImhhc1dlYnAiLCJyaWZmU2l6ZSIsInRvTG9jYWxlU3RyaW5nIiwic2FtcGxlVGV4dCIsInJlcGxhY2UiLCJsaW5lcyIsInB1c2giLCJmb3JFYWNoIiwibGluZSIsImluZGV4IiwiY3JlYXRlSW1hZ2VCaXRtYXBXaXRoRmFsbGJhY2siLCJieXRlcyIsImZhbGxiYWNrQmxvYiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/image/render.ts\n"));

/***/ })

});