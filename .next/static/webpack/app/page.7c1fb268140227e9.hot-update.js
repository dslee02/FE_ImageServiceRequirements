"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/crypto/decrypt.ts":
/*!*******************************!*\
  !*** ./lib/crypto/decrypt.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptHeadAESGCM: () => (/* binding */ decryptHeadAESGCM),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes)\n/* harmony export */ });\n/**\n * WebCrypto API를 사용한 AES-GCM 복호화 유틸리티\n */ function hexToBytes(hex) {\n    console.log(\"\\uD83D\\uDD22 Hex to Bytes 변환: \".concat(hex.length, \"자 hex 문자열\"));\n    if (hex.length % 2 !== 0) {\n        console.error('❌ Hex 문자열 길이 오류: 홀수 길이');\n        throw new Error(\"hex 문자열의 길이가 홀수입니다.\");\n    }\n    const matches = hex.match(/.{1,2}/g);\n    if (!matches) {\n        console.error('❌ Hex 문자열 파싱 실패');\n        throw new Error(\"잘못된 hex 문자열입니다.\");\n    }\n    const bytes = new Uint8Array(matches.map((byte)=>parseInt(byte, 16)));\n    console.log(\"✅ Hex 변환 완료: \".concat(bytes.length, \" bytes\"));\n    return bytes;\n}\nasync function decryptHeadAESGCM(keyHex, iv, cipher, tag) {\n    console.log('\\n🔐 === AES-GCM 복호화 시작 ===');\n    console.log(\"\\uD83D\\uDD11 입력 파라미터:\");\n    console.log(\"  - Key (hex): \".concat(keyHex.length, \"자 (\").concat(keyHex.substring(0, 16), \"...\").concat(keyHex.substring(-8), \")\"));\n    console.log(\"  - IV: \".concat(iv.length, \" bytes\"));\n    console.log(\"  - Cipher: \".concat(cipher.length.toLocaleString(), \" bytes\"));\n    console.log(\"  - Tag: \".concat(tag.length, \" bytes\"));\n    try {\n        const keyBytes = hexToBytes(keyHex);\n        if (keyBytes.length !== 32) {\n            console.error(\"❌ AES-256 키 길이 오류: \".concat(keyBytes.length, \" bytes !== 32 bytes\"));\n            throw new Error(\"AES-256 키는 32바이트여야 합니다. 현재: \".concat(keyBytes.length, \"바이트\"));\n        }\n        console.log(\"✅ AES-256 키 크기 확인: \".concat(keyBytes.length, \" bytes\"));\n        console.log('🔄 WebCrypto API를 사용한 AES-GCM 복호화 시작');\n        const startTime = Date.now();\n        // WebCrypto API로 키 가져오기\n        const cryptoKey = await window.crypto.subtle.importKey(\"raw\", keyBytes, {\n            name: \"AES-GCM\"\n        }, false, [\n            \"decrypt\"\n        ]);\n        // tag는 cipher 뒤에 붙여야 함\n        const cipherWithTag = new Uint8Array(cipher.length + tag.length);\n        cipherWithTag.set(cipher, 0);\n        cipherWithTag.set(tag, cipher.length);\n        console.log(\"  \\uD83D\\uDD04 복호화 진행 중... (\".concat(cipherWithTag.length.toLocaleString(), \" bytes)\"));\n        // AES-GCM 복호화 실행\n        const decrypted = await window.crypto.subtle.decrypt({\n            name: \"AES-GCM\",\n            iv\n        }, cryptoKey, cipherWithTag);\n        const endTime = Date.now();\n        console.log(\"✅ WebCrypto API 복호화 완료: \".concat(endTime - startTime, \"ms 소요\"));\n        const decryptedBytes = new Uint8Array(decrypted);\n        console.log('🔍 복호화 결과 분석:');\n        console.log(\"  - 복호화된 데이터 크기: \".concat(decryptedBytes.length.toLocaleString(), \" bytes\"));\n        // 복호화 결과에서 패턴 확인 (처음 2000바이트 확인)\n        const resultStr = new TextDecoder('utf-8', {\n            fatal: false\n        }).decode(decryptedBytes.slice(0, 2000));\n        console.log('  - 복호화된 데이터 샘플 (UTF-8):', resultStr.slice(0, 100) + '...');\n        // 헤더 바이트 분석\n        console.log('  - 바이너리 헤더 (hex):', Array.from(decryptedBytes.slice(0, 16)).map((b)=>b.toString(16).padStart(2, '0')).join(' '));\n        // 식별 패턴 확인\n        if (resultStr.includes('ENCRYPTED_DEMO_IMAGE_SUCCESS')) {\n            console.log('  ✅ 복호화 검증: 식별 패턴 \"ENCRYPTED_DEMO_IMAGE_SUCCESS\" 확인됨');\n        } else {\n            console.log('  ⚠️ 복호화 검증: 식별 패턴 미발견');\n        }\n        // 이미지 헤더 확인 및 실제 크기 계산\n        const isRiff = decryptedBytes[0] === 0x52 && decryptedBytes[1] === 0x49 && decryptedBytes[2] === 0x46 && decryptedBytes[3] === 0x46;\n        const isWebp = isRiff && decryptedBytes[8] === 0x57 && decryptedBytes[9] === 0x45 && decryptedBytes[10] === 0x42 && decryptedBytes[11] === 0x50;\n        const isJpeg = decryptedBytes[0] === 0xFF && decryptedBytes[1] === 0xD8 && decryptedBytes[2] === 0xFF;\n        if (isRiff && isWebp) {\n            console.log('  ✅ 이미지 검증: 유효한 RIFF/WebP 헤더 발견');\n            // WebP 실제 파일 크기 추출 (RIFF 헤더의 크기 필드)\n            const riffSize = (decryptedBytes[4] | decryptedBytes[5] << 8 | decryptedBytes[6] << 16 | decryptedBytes[7] << 24) + 8;\n            console.log(\"  - RIFF 파일 크기: \".concat(riffSize.toLocaleString(), \" bytes\"));\n            // 실제 이미지 크기만큼만 반환 (패딩 제거)\n            const actualImageData = decryptedBytes.slice(0, Math.min(riffSize, decryptedBytes.length));\n            console.log(\"  - 패딩 제거 후 이미지 크기: \".concat(actualImageData.length.toLocaleString(), \" bytes\"));\n            console.log('🔐 === AES-GCM 복호화 완료 ===\\n');\n            return actualImageData;\n        } else if (isJpeg) {\n            console.log('  ✅ 이미지 검증: JPEG 헤더 발견');\n            // JPEG 끝 마커(FFD9) 찾기\n            let jpegEnd = decryptedBytes.length;\n            for(let i = 0; i < decryptedBytes.length - 1; i++){\n                if (decryptedBytes[i] === 0xFF && decryptedBytes[i + 1] === 0xD9) {\n                    jpegEnd = i + 2; // FFD9 마커 포함\n                    break;\n                }\n            }\n            const actualImageData = decryptedBytes.slice(0, jpegEnd);\n            console.log(\"  - JPEG 실제 크기: \".concat(actualImageData.length.toLocaleString(), \" bytes (패딩 제거)\"));\n            console.log('🔐 === AES-GCM 복호화 완료 ===\\n');\n            return actualImageData;\n        } else if (isRiff) {\n            console.log('  ⚠️ 이미지 검증: RIFF 헤더는 있으나 WebP 시그니처 없음');\n        } else {\n            console.log('  ❌ 이미지 검증: 유효한 이미지 헤더 미발견');\n        }\n        console.log('🔐 === AES-GCM 복호화 완료 ===\\n');\n        return decryptedBytes;\n    } catch (error) {\n        console.error('❌ 복호화 오류:', error);\n        console.error('🔐 === AES-GCM 복호화 실패 ===\\n');\n        throw new Error(\"복호화 실패: \".concat(error instanceof Error ? error.message : String(error)));\n    }\n} // 기존 XOR 기반 구현 (주석 처리)\n /*\nexport async function decryptHeadAESGCM_OLD(\n  keyHex: string,\n  iv: Uint8Array,\n  cipher: Uint8Array,\n  _tag: Uint8Array\n): Promise<Uint8Array> {\n  console.log('\\n🔐 === AES-GCM 복호화 시작 (OLD XOR 방식) ===');\n  console.log(`🔑 입력 파라미터:`);\n  console.log(`  - Key (hex): ${keyHex.length}자 (${keyHex.substring(0, 16)}...${keyHex.substring(-8)})`);\n  console.log(`  - IV: ${iv.length} bytes`);\n  console.log(`  - Cipher: ${cipher.length.toLocaleString()} bytes`);\n  console.log(`  - Tag: ${_tag.length} bytes (unused in demo)`);\n  \n  try {\n    const keyBytes = hexToBytes(keyHex);\n    \n    if (keyBytes.length !== 32) {\n      console.error(`❌ AES-256 키 길이 오류: ${keyBytes.length} bytes !== 32 bytes`);\n      throw new Error(`AES-256 키는 32바이트여야 합니다. 현재: ${keyBytes.length}바이트`);\n    }\n    \n    console.log(`✅ AES-256 키 크기 확인: ${keyBytes.length} bytes`);\n\n    console.log('🔄 XOR 기반 복호화 시작 (데모용 - 실제 AES-GCM 대신)');\n    console.log('⚠️  주의: 실서비스에서는 Web Crypto API를 사용해야 합니다');\n    \n    const decrypted = new Uint8Array(cipher.length);\n    const startTime = Date.now();\n    \n    // XOR 복호화 진행\n    for (let i = 0; i < cipher.length; i++) {\n      decrypted[i] = cipher[i] ^ keyBytes[i % keyBytes.length] ^ iv[i % iv.length];\n      \n      // 진행률 표시 (10% 단위)\n      if (i > 0 && i % Math.floor(cipher.length / 10) === 0) {\n        const progress = Math.round((i / cipher.length) * 100);\n        console.log(`  🔄 복호화 진행: ${progress}% (${i.toLocaleString()}/${cipher.length.toLocaleString()} bytes)`);\n      }\n    }\n    \n    const endTime = Date.now();\n    console.log(`✅ XOR 복호화 완료: ${endTime - startTime}ms 소요`);\n\n    \n    console.log('🔍 복호화 결과 분석:');\n    console.log(`  - 복호화된 데이터 크기: ${decrypted.length.toLocaleString()} bytes`);\n    \n    // 복호화 결과에서 패턴 확인 (처음 2000바이트 확인)\n    const resultStr = new TextDecoder('utf-8', { fatal: false }).decode(decrypted.slice(0, 2000));\n    console.log('  - 복호화된 데이터 샘플 (UTF-8):', resultStr.slice(0, 100) + '...');\n    \n    // 헤더 바이트 분석\n    console.log('  - 바이너리 헤더 (hex):', Array.from(decrypted.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));\n    \n    // 식별 패턴 확인\n    if (resultStr.includes('ENCRYPTED_DEMO_IMAGE_SUCCESS')) {\n      console.log('  ✅ 복호화 검증: 식별 패턴 \"ENCRYPTED_DEMO_IMAGE_SUCCESS\" 확인됨');\n    } else {\n      console.log('  ⚠️ 복호화 검증: 식별 패턴 미발견');\n    }\n    \n    // 이미지 헤더 확인\n    const isRiff = decrypted[0] === 0x52 && decrypted[1] === 0x49 && decrypted[2] === 0x46 && decrypted[3] === 0x46;\n    const isWebp = isRiff && decrypted[8] === 0x57 && decrypted[9] === 0x45 && decrypted[10] === 0x42 && decrypted[11] === 0x50;\n    \n    if (isRiff && isWebp) {\n      console.log('  ✅ 이미지 검증: 유효한 RIFF/WebP 헤더 발견');\n      \n      // WebP 크기 정보 추출\n      const riffSize = (decrypted[4] | (decrypted[5] << 8) | (decrypted[6] << 16) | (decrypted[7] << 24)) + 8;\n      console.log(`  - RIFF 파일 크기: ${riffSize.toLocaleString()} bytes`);\n    } else if (isRiff) {\n      console.log('  ⚠️ 이미지 검증: RIFF 헤더는 있으나 WebP 시그니처 없음');\n    } else {\n      console.log('  ❌ 이미지 검증: 유효한 이미지 헤더 미발견');\n    }\n\n    \n    console.log('🔐 === AES-GCM 복호화 완료 ===\\n');\n    return decrypted;\n    \n  } catch (error) {\n    console.error('❌ 복호화 오류:', error);\n    console.error('🔐 === AES-GCM 복호화 실패 ===\\n');\n    throw new Error(`복호화 실패: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n*/ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jcnlwdG8vZGVjcnlwdC50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBRU0sU0FBU0EsV0FBV0MsR0FBVztJQUNwQ0MsUUFBUUMsR0FBRyxDQUFDLGlDQUFrQyxPQUFYRixJQUFJRyxNQUFNLEVBQUM7SUFFOUMsSUFBSUgsSUFBSUcsTUFBTSxHQUFHLE1BQU0sR0FBRztRQUN4QkYsUUFBUUcsS0FBSyxDQUFDO1FBQ2QsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsTUFBTUMsVUFBVU4sSUFBSU8sS0FBSyxDQUFDO0lBQzFCLElBQUksQ0FBQ0QsU0FBUztRQUNaTCxRQUFRRyxLQUFLLENBQUM7UUFDZCxNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxNQUFNRyxRQUFRLElBQUlDLFdBQVdILFFBQVFJLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUUMsU0FBU0QsTUFBTTtJQUNoRVYsUUFBUUMsR0FBRyxDQUFDLGdCQUE2QixPQUFiTSxNQUFNTCxNQUFNLEVBQUM7SUFDekMsT0FBT0s7QUFDVDtBQUVPLGVBQWVLLGtCQUNwQkMsTUFBYyxFQUNkQyxFQUFjLEVBQ2RDLE1BQWtCLEVBQ2xCQyxHQUFlO0lBRWZoQixRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFFO0lBQ2JELFFBQVFDLEdBQUcsQ0FBQyxrQkFBcUNZLE9BQW5CQSxPQUFPWCxNQUFNLEVBQUMsT0FBa0NXLE9BQTdCQSxPQUFPSSxTQUFTLENBQUMsR0FBRyxLQUFJLE9BQTBCLE9BQXJCSixPQUFPSSxTQUFTLENBQUMsQ0FBQyxJQUFHO0lBQ25HakIsUUFBUUMsR0FBRyxDQUFDLFdBQXFCLE9BQVZhLEdBQUdaLE1BQU0sRUFBQztJQUNqQ0YsUUFBUUMsR0FBRyxDQUFDLGVBQThDLE9BQS9CYyxPQUFPYixNQUFNLENBQUNnQixjQUFjLElBQUc7SUFDMURsQixRQUFRQyxHQUFHLENBQUMsWUFBdUIsT0FBWGUsSUFBSWQsTUFBTSxFQUFD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QU8vQixPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyxhQUFhQTtRQUMzQkgsUUFBUUcsS0FBSyxDQUFDO1FBQ2QsTUFBTSxJQUFJQyxNQUFNLFdBQWtFLE9BQXZERCxpQkFBaUJDLFFBQVFELE1BQU1xRCxPQUFPLEdBQUdDLE9BQU90RDtJQUM3RTtBQUNGLEVBRUEsdUJBQXVCO0NBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0ZBIiwic291cmNlcyI6WyIvVXNlcnMvZGFzb2xsZWUvRG93bmxvYWRzL0dpdEFsYWRpbi9GRV9JbWFnZVNlcnZpY2VSZXF1aXJlbWVudHMvbGliL2NyeXB0by9kZWNyeXB0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2ViQ3J5cHRvIEFQSeulvCDsgqzsmqntlZwgQUVTLUdDTSDrs7XtmLjtmZQg7Jyg7Yu466as7YuwXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgY29uc29sZS5sb2coYPCflKIgSGV4IHRvIEJ5dGVzIOuzgO2ZmDogJHtoZXgubGVuZ3RofeyekCBoZXgg66y47J6Q7Je0YCk7XG4gIFxuICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICBjb25zb2xlLmVycm9yKCfinYwgSGV4IOusuOyekOyXtCDquLjsnbQg7Jik66WYOiDtmYDsiJgg6ri47J20Jyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IOusuOyekOyXtOydmCDquLjsnbTqsIAg7ZmA7IiY7J6F64uI64ukLlwiKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSBoZXgubWF0Y2goLy57MSwyfS9nKTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEhleCDrrLjsnpDsl7Qg7YyM7IuxIOyLpO2MqCcpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIuyemOuqu+uQnCBoZXgg66y47J6Q7Je07J6F64uI64ukLlwiKTtcbiAgfVxuXG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobWF0Y2hlcy5tYXAoYnl0ZSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbiAgY29uc29sZS5sb2coYOKchSBIZXgg67OA7ZmYIOyZhOujjDogJHtieXRlcy5sZW5ndGh9IGJ5dGVzYCk7XG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRIZWFkQUVTR0NNKFxuICBrZXlIZXg6IHN0cmluZyxcbiAgaXY6IFVpbnQ4QXJyYXksXG4gIGNpcGhlcjogVWludDhBcnJheSxcbiAgdGFnOiBVaW50OEFycmF5XG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgY29uc29sZS5sb2coJ1xcbvCflJAgPT09IEFFUy1HQ00g67O17Zi47ZmUIOyLnOyekSA9PT0nKTtcbiAgY29uc29sZS5sb2coYPCflJEg7J6F66ClIO2MjOudvOuvuO2EsDpgKTtcbiAgY29uc29sZS5sb2coYCAgLSBLZXkgKGhleCk6ICR7a2V5SGV4Lmxlbmd0aH3snpAgKCR7a2V5SGV4LnN1YnN0cmluZygwLCAxNil9Li4uJHtrZXlIZXguc3Vic3RyaW5nKC04KX0pYCk7XG4gIGNvbnNvbGUubG9nKGAgIC0gSVY6ICR7aXYubGVuZ3RofSBieXRlc2ApO1xuICBjb25zb2xlLmxvZyhgICAtIENpcGhlcjogJHtjaXBoZXIubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzYCk7XG4gIGNvbnNvbGUubG9nKGAgIC0gVGFnOiAke3RhZy5sZW5ndGh9IGJ5dGVzYCk7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGtleUJ5dGVzID0gaGV4VG9CeXRlcyhrZXlIZXgpO1xuICAgIFxuICAgIGlmIChrZXlCeXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgQUVTLTI1NiDtgqQg6ri47J20IOyYpOulmDogJHtrZXlCeXRlcy5sZW5ndGh9IGJ5dGVzICE9PSAzMiBieXRlc2ApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRVMtMjU2IO2CpOuKlCAzMuuwlOydtO2KuOyXrOyVvCDtlanri4jri6QuIO2YhOyerDogJHtrZXlCeXRlcy5sZW5ndGh967CU7J207Yq4YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDinIUgQUVTLTI1NiDtgqQg7YGs6riwIO2ZleyduDogJHtrZXlCeXRlcy5sZW5ndGh9IGJ5dGVzYCk7XG5cbiAgICBjb25zb2xlLmxvZygn8J+UhCBXZWJDcnlwdG8gQVBJ66W8IOyCrOyaqe2VnCBBRVMtR0NNIOuzte2YuO2ZlCDsi5zsnpEnKTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIFdlYkNyeXB0byBBUEnroZwg7YKkIOqwgOyguOyYpOq4sFxuICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgIFwicmF3XCIsXG4gICAgICBrZXlCeXRlcyxcbiAgICAgIHsgbmFtZTogXCJBRVMtR0NNXCIgfSxcbiAgICAgIGZhbHNlLFxuICAgICAgW1wiZGVjcnlwdFwiXVxuICAgICk7XG4gICAgXG4gICAgLy8gdGFn64qUIGNpcGhlciDrkqTsl5Ag67aZ7Jes7JW8IO2VqFxuICAgIGNvbnN0IGNpcGhlcldpdGhUYWcgPSBuZXcgVWludDhBcnJheShjaXBoZXIubGVuZ3RoICsgdGFnLmxlbmd0aCk7XG4gICAgY2lwaGVyV2l0aFRhZy5zZXQoY2lwaGVyLCAwKTtcbiAgICBjaXBoZXJXaXRoVGFnLnNldCh0YWcsIGNpcGhlci5sZW5ndGgpO1xuXG4gICAgY29uc29sZS5sb2coYCAg8J+UhCDrs7XtmLjtmZQg7KeE7ZaJIOykkS4uLiAoJHtjaXBoZXJXaXRoVGFnLmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBieXRlcylgKTtcbiAgICBcbiAgICAvLyBBRVMtR0NNIOuzte2YuO2ZlCDsi6TtlolcbiAgICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgICAgeyBuYW1lOiBcIkFFUy1HQ01cIiwgaXYgfSxcbiAgICAgIGNyeXB0b0tleSxcbiAgICAgIGNpcGhlcldpdGhUYWdcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKGDinIUgV2ViQ3J5cHRvIEFQSSDrs7XtmLjtmZQg7JmE66OMOiAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXMg7IaM7JqUYCk7XG5cbiAgICBjb25zdCBkZWNyeXB0ZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0g67O17Zi47ZmUIOqysOqzvCDrtoTshJ06Jyk7XG4gICAgY29uc29sZS5sb2coYCAgLSDrs7XtmLjtmZTrkJwg642w7J207YSwIO2BrOq4sDogJHtkZWNyeXB0ZWRCeXRlcy5sZW5ndGgudG9Mb2NhbGVTdHJpbmcoKX0gYnl0ZXNgKTtcbiAgICBcbiAgICAvLyDrs7XtmLjtmZQg6rKw6rO87JeQ7IScIO2MqO2EtCDtmZXsnbggKOyymOydjCAyMDAw67CU7J207Yq4IO2ZleyduClcbiAgICBjb25zdCByZXN1bHRTdHIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogZmFsc2UgfSkuZGVjb2RlKGRlY3J5cHRlZEJ5dGVzLnNsaWNlKDAsIDIwMDApKTtcbiAgICBjb25zb2xlLmxvZygnICAtIOuzte2YuO2ZlOuQnCDrjbDsnbTthLAg7IOY7ZSMIChVVEYtOCk6JywgcmVzdWx0U3RyLnNsaWNlKDAsIDEwMCkgKyAnLi4uJyk7XG4gICAgXG4gICAgLy8g7Zek642UIOuwlOydtO2KuCDrtoTshJ1cbiAgICBjb25zb2xlLmxvZygnICAtIOuwlOydtOuEiOumrCDtl6TrjZQgKGhleCk6JywgQXJyYXkuZnJvbShkZWNyeXB0ZWRCeXRlcy5zbGljZSgwLCAxNikpLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJyAnKSk7XG4gICAgXG4gICAgLy8g7Iud67OEIO2MqO2EtCDtmZXsnbhcbiAgICBpZiAocmVzdWx0U3RyLmluY2x1ZGVzKCdFTkNSWVBURURfREVNT19JTUFHRV9TVUNDRVNTJykpIHtcbiAgICAgIGNvbnNvbGUubG9nKCcgIOKchSDrs7XtmLjtmZQg6rKA7KadOiDsi53rs4Qg7Yyo7YS0IFwiRU5DUllQVEVEX0RFTU9fSU1BR0VfU1VDQ0VTU1wiIO2ZleyduOuQqCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnICDimqDvuI8g67O17Zi47ZmUIOqygOymnTog7Iud67OEIO2MqO2EtCDrr7jrsJzqsqwnKTtcbiAgICB9XG4gICAgXG4gICAgLy8g7J2066+47KeAIO2XpOuNlCDtmZXsnbgg67CPIOyLpOygnCDtgazquLAg6rOE7IKwXG4gICAgY29uc3QgaXNSaWZmID0gZGVjcnlwdGVkQnl0ZXNbMF0gPT09IDB4NTIgJiYgZGVjcnlwdGVkQnl0ZXNbMV0gPT09IDB4NDkgJiYgZGVjcnlwdGVkQnl0ZXNbMl0gPT09IDB4NDYgJiYgZGVjcnlwdGVkQnl0ZXNbM10gPT09IDB4NDY7XG4gICAgY29uc3QgaXNXZWJwID0gaXNSaWZmICYmIGRlY3J5cHRlZEJ5dGVzWzhdID09PSAweDU3ICYmIGRlY3J5cHRlZEJ5dGVzWzldID09PSAweDQ1ICYmIGRlY3J5cHRlZEJ5dGVzWzEwXSA9PT0gMHg0MiAmJiBkZWNyeXB0ZWRCeXRlc1sxMV0gPT09IDB4NTA7XG4gICAgY29uc3QgaXNKcGVnID0gZGVjcnlwdGVkQnl0ZXNbMF0gPT09IDB4RkYgJiYgZGVjcnlwdGVkQnl0ZXNbMV0gPT09IDB4RDggJiYgZGVjcnlwdGVkQnl0ZXNbMl0gPT09IDB4RkY7XG4gICAgXG4gICAgaWYgKGlzUmlmZiAmJiBpc1dlYnApIHtcbiAgICAgIGNvbnNvbGUubG9nKCcgIOKchSDsnbTrr7jsp4Ag6rKA7KadOiDsnKDtmqjtlZwgUklGRi9XZWJQIO2XpOuNlCDrsJzqsqwnKTtcbiAgICAgIFxuICAgICAgLy8gV2ViUCDsi6TsoJwg7YyM7J28IO2BrOq4sCDstpTstpwgKFJJRkYg7Zek642U7J2YIO2BrOq4sCDtlYTrk5wpXG4gICAgICBjb25zdCByaWZmU2l6ZSA9IChkZWNyeXB0ZWRCeXRlc1s0XSB8IChkZWNyeXB0ZWRCeXRlc1s1XSA8PCA4KSB8IChkZWNyeXB0ZWRCeXRlc1s2XSA8PCAxNikgfCAoZGVjcnlwdGVkQnl0ZXNbN10gPDwgMjQpKSArIDg7XG4gICAgICBjb25zb2xlLmxvZyhgICAtIFJJRkYg7YyM7J28IO2BrOq4sDogJHtyaWZmU2l6ZS50b0xvY2FsZVN0cmluZygpfSBieXRlc2ApO1xuICAgICAgXG4gICAgICAvLyDsi6TsoJwg7J2066+47KeAIO2BrOq4sOunjO2BvOunjCDrsJjtmZggKO2MqOuUqSDsoJzqsbApXG4gICAgICBjb25zdCBhY3R1YWxJbWFnZURhdGEgPSBkZWNyeXB0ZWRCeXRlcy5zbGljZSgwLCBNYXRoLm1pbihyaWZmU2l6ZSwgZGVjcnlwdGVkQnl0ZXMubGVuZ3RoKSk7XG4gICAgICBjb25zb2xlLmxvZyhgICAtIO2MqOuUqSDsoJzqsbAg7ZuEIOydtOuvuOyngCDtgazquLA6ICR7YWN0dWFsSW1hZ2VEYXRhLmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBieXRlc2ApO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UkCA9PT0gQUVTLUdDTSDrs7XtmLjtmZQg7JmE66OMID09PVxcbicpO1xuICAgICAgcmV0dXJuIGFjdHVhbEltYWdlRGF0YTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiAoaXNKcGVnKSB7XG4gICAgICBjb25zb2xlLmxvZygnICDinIUg7J2066+47KeAIOqygOymnTogSlBFRyDtl6TrjZQg67Cc6rKsJyk7XG4gICAgICBcbiAgICAgIC8vIEpQRUcg64GdIOuniOy7pChGRkQ5KSDssL7quLBcbiAgICAgIGxldCBqcGVnRW5kID0gZGVjcnlwdGVkQnl0ZXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNyeXB0ZWRCeXRlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGRlY3J5cHRlZEJ5dGVzW2ldID09PSAweEZGICYmIGRlY3J5cHRlZEJ5dGVzW2kgKyAxXSA9PT0gMHhEOSkge1xuICAgICAgICAgIGpwZWdFbmQgPSBpICsgMjsgLy8gRkZEOSDrp4jsu6Qg7Y+s7ZWoXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYWN0dWFsSW1hZ2VEYXRhID0gZGVjcnlwdGVkQnl0ZXMuc2xpY2UoMCwganBlZ0VuZCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAtIEpQRUcg7Iuk7KCcIO2BrOq4sDogJHthY3R1YWxJbWFnZURhdGEubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzICjtjKjrlKkg7KCc6rGwKWApO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UkCA9PT0gQUVTLUdDTSDrs7XtmLjtmZQg7JmE66OMID09PVxcbicpO1xuICAgICAgcmV0dXJuIGFjdHVhbEltYWdlRGF0YTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiAoaXNSaWZmKSB7XG4gICAgICBjb25zb2xlLmxvZygnICDimqDvuI8g7J2066+47KeAIOqygOymnTogUklGRiDtl6TrjZTripQg7J6I7Jy864KYIFdlYlAg7Iuc6re464uI7LKYIOyXhuydjCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnICDinYwg7J2066+47KeAIOqygOymnTog7Jyg7Zqo7ZWcIOydtOuvuOyngCDtl6TrjZQg66+467Cc6rKsJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ/CflJAgPT09IEFFUy1HQ00g67O17Zi47ZmUIOyZhOujjCA9PT1cXG4nKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkQnl0ZXM7XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIOuzte2YuO2ZlCDsmKTrpZg6JywgZXJyb3IpO1xuICAgIGNvbnNvbGUuZXJyb3IoJ/CflJAgPT09IEFFUy1HQ00g67O17Zi47ZmUIOyLpO2MqCA9PT1cXG4nKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYOuzte2YuO2ZlCDsi6TtjKg6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICB9XG59XG5cbi8vIOq4sOyhtCBYT1Ig6riw67CYIOq1rO2YhCAo7KO87ISdIOyymOumrClcbi8qXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdEhlYWRBRVNHQ01fT0xEKFxuICBrZXlIZXg6IHN0cmluZyxcbiAgaXY6IFVpbnQ4QXJyYXksXG4gIGNpcGhlcjogVWludDhBcnJheSxcbiAgX3RhZzogVWludDhBcnJheVxuKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gIGNvbnNvbGUubG9nKCdcXG7wn5SQID09PSBBRVMtR0NNIOuzte2YuO2ZlCDsi5zsnpEgKE9MRCBYT1Ig67Cp7IudKSA9PT0nKTtcbiAgY29uc29sZS5sb2coYPCflJEg7J6F66ClIO2MjOudvOuvuO2EsDpgKTtcbiAgY29uc29sZS5sb2coYCAgLSBLZXkgKGhleCk6ICR7a2V5SGV4Lmxlbmd0aH3snpAgKCR7a2V5SGV4LnN1YnN0cmluZygwLCAxNil9Li4uJHtrZXlIZXguc3Vic3RyaW5nKC04KX0pYCk7XG4gIGNvbnNvbGUubG9nKGAgIC0gSVY6ICR7aXYubGVuZ3RofSBieXRlc2ApO1xuICBjb25zb2xlLmxvZyhgICAtIENpcGhlcjogJHtjaXBoZXIubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzYCk7XG4gIGNvbnNvbGUubG9nKGAgIC0gVGFnOiAke190YWcubGVuZ3RofSBieXRlcyAodW51c2VkIGluIGRlbW8pYCk7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGtleUJ5dGVzID0gaGV4VG9CeXRlcyhrZXlIZXgpO1xuICAgIFxuICAgIGlmIChrZXlCeXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgQUVTLTI1NiDtgqQg6ri47J20IOyYpOulmDogJHtrZXlCeXRlcy5sZW5ndGh9IGJ5dGVzICE9PSAzMiBieXRlc2ApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRVMtMjU2IO2CpOuKlCAzMuuwlOydtO2KuOyXrOyVvCDtlanri4jri6QuIO2YhOyerDogJHtrZXlCeXRlcy5sZW5ndGh967CU7J207Yq4YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDinIUgQUVTLTI1NiDtgqQg7YGs6riwIO2ZleyduDogJHtrZXlCeXRlcy5sZW5ndGh9IGJ5dGVzYCk7XG5cbiAgICBjb25zb2xlLmxvZygn8J+UhCBYT1Ig6riw67CYIOuzte2YuO2ZlCDsi5zsnpEgKOuNsOuqqOyaqSAtIOyLpOygnCBBRVMtR0NNIOuMgOyLoCknKTtcbiAgICBjb25zb2xlLmxvZygn4pqg77iPICDso7zsnZg6IOyLpOyEnOu5hOyKpOyXkOyEnOuKlCBXZWIgQ3J5cHRvIEFQSeulvCDsgqzsmqntlbTslbwg7ZWp64uI64ukJyk7XG4gICAgXG4gICAgY29uc3QgZGVjcnlwdGVkID0gbmV3IFVpbnQ4QXJyYXkoY2lwaGVyLmxlbmd0aCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICAvLyBYT1Ig67O17Zi47ZmUIOynhO2WiVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWNyeXB0ZWRbaV0gPSBjaXBoZXJbaV0gXiBrZXlCeXRlc1tpICUga2V5Qnl0ZXMubGVuZ3RoXSBeIGl2W2kgJSBpdi5sZW5ndGhdO1xuICAgICAgXG4gICAgICAvLyDsp4TtlonrpaAg7ZGc7IucICgxMCUg64uo7JyEKVxuICAgICAgaWYgKGkgPiAwICYmIGkgJSBNYXRoLmZsb29yKGNpcGhlci5sZW5ndGggLyAxMCkgPT09IDApIHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKChpIC8gY2lwaGVyLmxlbmd0aCkgKiAxMDApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICDwn5SEIOuzte2YuO2ZlCDsp4Ttlok6ICR7cHJvZ3Jlc3N9JSAoJHtpLnRvTG9jYWxlU3RyaW5nKCl9LyR7Y2lwaGVyLmxlbmd0aC50b0xvY2FsZVN0cmluZygpfSBieXRlcylgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coYOKchSBYT1Ig67O17Zi47ZmUIOyZhOujjDogJHtlbmRUaW1lIC0gc3RhcnRUaW1lfW1zIOyGjOyalGApO1xuXG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0g67O17Zi47ZmUIOqysOqzvCDrtoTshJ06Jyk7XG4gICAgY29uc29sZS5sb2coYCAgLSDrs7XtmLjtmZTrkJwg642w7J207YSwIO2BrOq4sDogJHtkZWNyeXB0ZWQubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzYCk7XG4gICAgXG4gICAgLy8g67O17Zi47ZmUIOqysOqzvOyXkOyEnCDtjKjthLQg7ZmV7J24ICjsspjsnYwgMjAwMOuwlOydtO2KuCDtmZXsnbgpXG4gICAgY29uc3QgcmVzdWx0U3RyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IGZhbHNlIH0pLmRlY29kZShkZWNyeXB0ZWQuc2xpY2UoMCwgMjAwMCkpO1xuICAgIGNvbnNvbGUubG9nKCcgIC0g67O17Zi47ZmU65CcIOuNsOydtO2EsCDsg5jtlIwgKFVURi04KTonLCByZXN1bHRTdHIuc2xpY2UoMCwgMTAwKSArICcuLi4nKTtcbiAgICBcbiAgICAvLyDtl6TrjZQg67CU7J207Yq4IOu2hOyEnVxuICAgIGNvbnNvbGUubG9nKCcgIC0g67CU7J2064SI66asIO2XpOuNlCAoaGV4KTonLCBBcnJheS5mcm9tKGRlY3J5cHRlZC5zbGljZSgwLCAxNikpLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJyAnKSk7XG4gICAgXG4gICAgLy8g7Iud67OEIO2MqO2EtCDtmZXsnbhcbiAgICBpZiAocmVzdWx0U3RyLmluY2x1ZGVzKCdFTkNSWVBURURfREVNT19JTUFHRV9TVUNDRVNTJykpIHtcbiAgICAgIGNvbnNvbGUubG9nKCcgIOKchSDrs7XtmLjtmZQg6rKA7KadOiDsi53rs4Qg7Yyo7YS0IFwiRU5DUllQVEVEX0RFTU9fSU1BR0VfU1VDQ0VTU1wiIO2ZleyduOuQqCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnICDimqDvuI8g67O17Zi47ZmUIOqygOymnTog7Iud67OEIO2MqO2EtCDrr7jrsJzqsqwnKTtcbiAgICB9XG4gICAgXG4gICAgLy8g7J2066+47KeAIO2XpOuNlCDtmZXsnbhcbiAgICBjb25zdCBpc1JpZmYgPSBkZWNyeXB0ZWRbMF0gPT09IDB4NTIgJiYgZGVjcnlwdGVkWzFdID09PSAweDQ5ICYmIGRlY3J5cHRlZFsyXSA9PT0gMHg0NiAmJiBkZWNyeXB0ZWRbM10gPT09IDB4NDY7XG4gICAgY29uc3QgaXNXZWJwID0gaXNSaWZmICYmIGRlY3J5cHRlZFs4XSA9PT0gMHg1NyAmJiBkZWNyeXB0ZWRbOV0gPT09IDB4NDUgJiYgZGVjcnlwdGVkWzEwXSA9PT0gMHg0MiAmJiBkZWNyeXB0ZWRbMTFdID09PSAweDUwO1xuICAgIFxuICAgIGlmIChpc1JpZmYgJiYgaXNXZWJwKSB7XG4gICAgICBjb25zb2xlLmxvZygnICDinIUg7J2066+47KeAIOqygOymnTog7Jyg7Zqo7ZWcIFJJRkYvV2ViUCDtl6TrjZQg67Cc6rKsJyk7XG4gICAgICBcbiAgICAgIC8vIFdlYlAg7YGs6riwIOygleuztCDstpTstpxcbiAgICAgIGNvbnN0IHJpZmZTaXplID0gKGRlY3J5cHRlZFs0XSB8IChkZWNyeXB0ZWRbNV0gPDwgOCkgfCAoZGVjcnlwdGVkWzZdIDw8IDE2KSB8IChkZWNyeXB0ZWRbN10gPDwgMjQpKSArIDg7XG4gICAgICBjb25zb2xlLmxvZyhgICAtIFJJRkYg7YyM7J28IO2BrOq4sDogJHtyaWZmU2l6ZS50b0xvY2FsZVN0cmluZygpfSBieXRlc2ApO1xuICAgIH0gZWxzZSBpZiAoaXNSaWZmKSB7XG4gICAgICBjb25zb2xlLmxvZygnICDimqDvuI8g7J2066+47KeAIOqygOymnTogUklGRiDtl6TrjZTripQg7J6I7Jy864KYIFdlYlAg7Iuc6re464uI7LKYIOyXhuydjCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnICDinYwg7J2066+47KeAIOqygOymnTog7Jyg7Zqo7ZWcIOydtOuvuOyngCDtl6TrjZQg66+467Cc6rKsJyk7XG4gICAgfVxuXG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflJAgPT09IEFFUy1HQ00g67O17Zi47ZmUIOyZhOujjCA9PT1cXG4nKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkO1xuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCDrs7XtmLjtmZQg7Jik66WYOicsIGVycm9yKTtcbiAgICBjb25zb2xlLmVycm9yKCfwn5SQID09PSBBRVMtR0NNIOuzte2YuO2ZlCDsi6TtjKggPT09XFxuJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGDrs7XtmLjtmZQg7Iuk7YyoOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgfVxufVxuKi8iXSwibmFtZXMiOlsiaGV4VG9CeXRlcyIsImhleCIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJlcnJvciIsIkVycm9yIiwibWF0Y2hlcyIsIm1hdGNoIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwibWFwIiwiYnl0ZSIsInBhcnNlSW50IiwiZGVjcnlwdEhlYWRBRVNHQ00iLCJrZXlIZXgiLCJpdiIsImNpcGhlciIsInRhZyIsInN1YnN0cmluZyIsInRvTG9jYWxlU3RyaW5nIiwia2V5Qnl0ZXMiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiY3J5cHRvS2V5Iiwid2luZG93IiwiY3J5cHRvIiwic3VidGxlIiwiaW1wb3J0S2V5IiwibmFtZSIsImNpcGhlcldpdGhUYWciLCJzZXQiLCJkZWNyeXB0ZWQiLCJkZWNyeXB0IiwiZW5kVGltZSIsImRlY3J5cHRlZEJ5dGVzIiwicmVzdWx0U3RyIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZSIsInNsaWNlIiwiQXJyYXkiLCJmcm9tIiwiYiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwiaW5jbHVkZXMiLCJpc1JpZmYiLCJpc1dlYnAiLCJpc0pwZWciLCJyaWZmU2l6ZSIsImFjdHVhbEltYWdlRGF0YSIsIk1hdGgiLCJtaW4iLCJqcGVnRW5kIiwiaSIsIm1lc3NhZ2UiLCJTdHJpbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/crypto/decrypt.ts\n"));

/***/ })

});